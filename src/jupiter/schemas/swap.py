# generated by datamodel-codegen:
#   filename:  swap.yaml

from __future__ import annotations

from enum import Enum
from typing import Dict, List, Optional

from pydantic import BaseModel, ConfigDict, Field, RootModel, conint


class AccountMeta(BaseModel):
    model_config = ConfigDict(
        extra='allow',
    )
    pubkey: str
    isSigner: bool
    isWritable: bool


class SwapMode(Enum):
    ExactIn = 'ExactIn'
    ExactOut = 'ExactOut'


class PlatformFee(BaseModel):
    model_config = ConfigDict(
        extra='allow',
    )
    amount: Optional[str] = None
    feeBps: Optional[int] = None


class SwapInfo(BaseModel):
    model_config = ConfigDict(
        extra='allow',
    )
    ammKey: str
    label: Optional[str] = None
    inputMint: str
    outputMint: str
    inAmount: str
    outAmount: str
    feeAmount: str
    feeMint: str


class PriorityLevel(Enum):
    medium = 'medium'
    high = 'high'
    veryHigh = 'veryHigh'


class PriorityLevelWithMaxLamports(BaseModel):
    model_config = ConfigDict(
        extra='allow',
    )
    priorityLevel: Optional[PriorityLevel] = None
    maxLamports: Optional[int] = None
    """
    - Maximum lamports to cap the priority fee estimation, to prevent overpaying

    """


class PrioritizationFeeLamports(BaseModel):
    model_config = ConfigDict(
        extra='allow',
    )
    priorityLevelWithMaxLamports: Optional[PriorityLevelWithMaxLamports] = None
    jitoTipLamports: Optional[int] = None
    """
    - Exact amount of tip to use in a tip instruction
    - Refer to Jito docs on how to estimate the tip amount based on percentiles
    - It has to be used together with a connection to a Jito RPC
    - [See their docs](https://docs.jito.wtf/)

    """


class SwapResponse(BaseModel):
    model_config = ConfigDict(
        extra='allow',
    )
    swapTransaction: str
    lastValidBlockHeight: int
    prioritizationFeeLamports: Optional[int] = None


class IndexedRouteMapResponse(BaseModel):
    model_config = ConfigDict(
        extra='allow',
    )
    mintKeys: List[str]
    """
    All the mints that are indexed to match in indexedRouteMap
    """
    indexedRouteMap: Dict[str, List[float]] = Field(
        ..., examples=[{'1': [2, 3, 4], '2': [1, 3, 4]}]
    )
    """
    All the possible route and their corresponding output mints
    """


class QuoteGetParametersQuery(BaseModel):
    inputMint: str
    outputMint: str
    amount: int
    slippageBps: Optional[int] = None
    swapMode: Optional[SwapMode] = 'ExactIn'
    dexes: Optional[List[str]] = None
    excludeDexes: Optional[List[str]] = None
    restrictIntermediateTokens: Optional[bool] = True
    onlyDirectRoutes: Optional[bool] = False
    asLegacyTransaction: Optional[bool] = False
    platformFeeBps: Optional[int] = None
    maxAccounts: Optional[int] = 64
    dynamicSlippage: Optional[bool] = False


class ProgramIdToLabelGetResponse(RootModel[Optional[Dict[str, str]]]):
    root: Optional[Dict[str, str]] = None


class Instruction(BaseModel):
    model_config = ConfigDict(
        extra='allow',
    )
    programId: str
    accounts: List[AccountMeta]
    data: str


class RoutePlanStep(BaseModel):
    model_config = ConfigDict(
        extra='allow',
    )
    swapInfo: SwapInfo
    percent: int
    bps: Optional[int] = None


class SwapInstructionsResponse(BaseModel):
    model_config = ConfigDict(
        extra='allow',
    )
    otherInstructions: Optional[List[Instruction]] = None
    """
    - If you set `{\"prioritizationFeeLamports\": {\"jitoTipLamports\": 5000}}`, you will see a custom tip instruction to Jito here.

    """
    computeBudgetInstructions: List[Instruction]
    """
    - To setup the compute budget for the transaction.

    """
    setupInstructions: List[Instruction]
    """
    - To setup required token accounts for the users.

    """
    swapInstruction: Instruction
    """
    - The actual swap instruction.

    """
    cleanupInstruction: Optional[Instruction] = None
    """
    - To wrap and unwrap the SOL.

    """
    addressLookupTableAddresses: List[str]
    """
    - The lookup table addresses if you are using versioned transaction.

    """


class QuoteResponse(BaseModel):
    model_config = ConfigDict(
        extra='allow',
    )
    inputMint: str
    inAmount: str
    outputMint: str
    outAmount: str
    """
    - Calculated output amount from routing engine
    - The value includes platform fees and DEX fees, excluding slippage

    """
    otherAmountThreshold: str
    """
    - Calculated minimum output amount after accounting for `slippageBps` on the `outAmount` value
    - Not used by `/swap` endpoint to build transaction

    """
    swapMode: SwapMode
    slippageBps: conint(ge=0)
    platformFee: Optional[PlatformFee] = None
    priceImpactPct: str
    routePlan: List[RoutePlanStep]
    contextSlot: Optional[int] = None
    timeTaken: Optional[float] = None


class SwapRequest(BaseModel):
    model_config = ConfigDict(
        extra='allow',
    )
    userPublicKey: str
    payer: Optional[str] = None
    """
    - Allow a custom payer to pay for the transaction fees and rent of token accounts
    - Note that users can close their ATAs elsewhere and have you reopen them again, your fees should account for this

    """
    wrapAndUnwrapSol: Optional[bool] = True
    """
    - To automatically wrap/unwrap SOL in the transaction, as WSOL is an SPL token while native SOL is not
    - When true, it will strictly use SOL amount to wrap it to swap, and each time after you swap, it will unwrap all WSOL back to SOL
    - When false, it will strictly use WSOL amount to swap, and each time after you swap, it will not unwrap the WSOL back to SOL
    - To set this parameter to false, you need to have the WSOL token account initialized
    - Parameter will be ignored if `destinationTokenAccount` is set because the `destinationTokenAccount` may belong to a different user that we have no authority to close

    """
    useSharedAccounts: Optional[bool] = None
    """
    - The default is determined dynamically by the routing engine, allowing us to optimize for compute units, etc
    - This enables the usage of shared program accounts, this is essential as complex routing will require multiple intermediate token accounts which the user might not have
    - If true, you do not need to handle the creation of intermediate token accounts for the user
    - Do note, shared accounts route will fail on some new AMMs (low liquidity token)

    """
    feeAccount: Optional[str] = None
    """
    - An token account that will be used to collect fees
    - The mint of the token account **can only be either the input or output mint of the swap**
    - You no longer are required to use the Referral Program
    - See [Add Fees](/docs/swap-api/add-fees-to-swap) guide for more details

    """
    trackingAccount: Optional[str] = None
    """
    - Specify any public key that belongs to you to track the transactions
    - Useful for integrators to get all the swap transactions from this public key
    - Query the data using a block explorer like Solscan/SolanaFM or query like Dune/Flipside

    """
    prioritizationFeeLamports: Optional[PrioritizationFeeLamports] = None
    """
    - To specify a level or amount of additional fees to prioritize the transaction
    - It can be used for EITHER priority fee OR Jito tip (not both at the same time)
    - If you want to include both, you will need to use `/swap-instructions` to add both at the same time

    """
    asLegacyTransaction: Optional[bool] = False
    """
    - Builds a legacy transaction rather than the default versioned transaction
    - Used together with `asLegacyTransaction` in `/quote`, otherwise the transaction might be too large

    """
    destinationTokenAccount: Optional[str] = None
    """
    - Public key of a token account that will be used to receive the token out of the swap
    - If not provided, the signer's token account will be used
    - If provided, we assume that the token account is already initialized

    """
    dynamicComputeUnitLimit: Optional[bool] = False
    """
    - When enabled, it will do a swap simulation to get the compute unit used and set it in ComputeBudget's compute unit limit
    - This incurs one extra RPC call to simulate this
    - We recommend to enable this to estimate compute unit correctly and reduce priority fees needed or have higher chance to be included in a block

    """
    skipUserAccountsRpcCalls: Optional[bool] = False
    """
    - When enabled, it will not do any additional RPC calls to check on required accounts
    - The returned swap transaction will still attempt to create required accounts regardless if it exists or not

    """
    dynamicSlippage: Optional[bool] = False
    """
    - When enabled, it estimates slippage and apply it in the swap transaction directly, overwriting the `slippageBps` parameter in the quote response.
    - Used together with `dynamicSlippage` in `/quote`, otherwise the slippage used will be the one in the `/quote`'s `slippageBps`
    - [See notes for more information](/docs/swap-api/send-swap-transaction#how-jupiter-estimates-slippage)

    """
    computeUnitPriceMicroLamports: Optional[int] = None
    """
    - To use an exact compute unit price to calculate priority fee
    - `computeUnitLimit (1400000) * computeUnitPriceMicroLamports`
    - We recommend using `prioritizationFeeLamports` and `dynamicComputeUnitLimit` instead of passing in your own compute unit price

    """
    blockhashSlotsToExpiry: Optional[int] = None
    """
    - Pass in the number of slots we want the transaction to be valid for
    - Example: If you pass in 10 slots, the transaction will be valid for ~400ms * 10 = approximately 4 seconds before it expires

    """
    quoteResponse: QuoteResponse
