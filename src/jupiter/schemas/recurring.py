# generated by datamodel-codegen:
#   filename:  recurring.yaml

from __future__ import annotations

from enum import Enum
from typing import Any, List, Literal, Optional, Union

from pydantic import AwareDatetime, BaseModel, ConfigDict, RootModel, conint


class CloseRecurringType(Enum):
    time = 'time'
    price = 'price'


class DepositPriceRecurring(BaseModel):
    model_config = ConfigDict(
        extra='allow',
    )
    amount: conint(ge=0)
    order: str
    """
    Base-58 account which is the Recurring Order account
    """
    user: str


class ExecuteRecurring(BaseModel):
    model_config = ConfigDict(
        extra='allow',
    )
    requestId: str
    signedTransaction: str


class Status(Enum):
    Success = 'Success'
    Failed = 'Failed'


class ExecuteRecurringResponse(BaseModel):
    model_config = ConfigDict(
        extra='allow',
    )
    error: Optional[str] = None
    order: Optional[str] = None
    """
    Base-58 account which is the Recurring Order account
    """
    signature: str
    status: Status


class OpenIxArgsWithoutIdx(BaseModel):
    model_config = ConfigDict(
        extra='allow',
    )
    depositAmount: conint(ge=0)
    incrementUsdcValue: conint(ge=0)
    interval: int
    """
    In unix seconds
    """
    startAt: Optional[int] = None
    """
    In unix timestamp
    """


class OrderHistoryResponse(BaseModel):
    model_config = ConfigDict(
        extra='allow',
    )
    action: str
    confirmedAt: AwareDatetime
    feeAmount: str
    feeMint: str
    inputAmount: str
    inputMint: str
    keeper: str
    orderKey: str
    outputAmount: str
    outputMint: str
    productMeta: Optional[Any] = None
    """
    Extra metadata for sub-products which will never be queried

    with filters.


    See structs `DbOrderHistoryValueAverageMeta` and
    `DbOrderHistoryPerpetualMeta`

    to craft the JSONB object.

    """
    rawFeeAmount: str
    rawInputAmount: str
    rawOutputAmount: str
    txId: str


class OrderState(Enum):
    active = 'active'
    history = 'history'


class PriceRecurringResponse(BaseModel):
    model_config = ConfigDict(
        extra='allow',
    )
    closeTx: str
    closedBy: str
    createdAt: AwareDatetime
    estimatedUsdcValueSpent: str
    inDeposited: str
    inLeft: str
    inUsed: str
    """
    Amount used to fulfill orders
    """
    inWithdrawn: str
    incrementalUsdValue: str
    inputMint: str
    openTx: str
    orderInterval: str
    orderKey: str
    outReceived: str
    """
    Amount received in escrow without auto-withdraw enabled
    """
    outWithdrawn: str
    """
    Amount withdrawn from escrow account with/without auto-withdraw
    enabled

    """
    outputMint: str
    rawEstimatedUsdcValueSpent: str
    rawInDeposited: str
    rawInLeft: str
    rawInUsed: str
    """
    Amount used to fulfill orders
    """
    rawInWithdrawn: str
    rawIncrementalUsdValue: str
    rawOutReceived: str
    """
    Amount received in escrow without auto-withdraw enabled
    """
    rawOutWithdrawn: str
    """
    Amount withdrawn from escrow account with/without auto-withdraw
    enabled

    """
    rawSupposedUsdValue: str
    startAt: AwareDatetime
    status: str
    supposedUsdValue: str
    trades: List[OrderHistoryResponse]
    updatedAt: AwareDatetime
    userPubkey: str


class RecurringOrderType(Enum):
    time = 'time'
    price = 'price'
    all = 'all'


class RecurringResponse(BaseModel):
    model_config = ConfigDict(
        extra='allow',
    )
    requestId: str
    """
    Required to make a request to `/execute`
    """
    transaction: str
    """
    Unsigned base-64 encoded transaction
    """


class RecurringType2(BaseModel):
    model_config = ConfigDict(
        extra='allow',
    )
    price: OpenIxArgsWithoutIdx


class TimeRecurringCreationParams(BaseModel):
    model_config = ConfigDict(
        extra='allow',
    )
    inAmount: conint(ge=0)
    interval: int
    """
    In unix seconds
    """
    maxPrice: Optional[float] = None
    minPrice: Optional[float] = None
    numberOfOrders: conint(ge=0)
    startAt: Optional[int] = None
    """
    In unix timestamp
    """


class TimeRecurringResponse(BaseModel):
    model_config = ConfigDict(
        extra='allow',
    )
    closeTx: str
    createdAt: AwareDatetime
    cycleFrequency: str
    inAmountPerCycle: str
    inDeposited: str
    inUsed: str
    inWithdrawn: str
    inputMint: str
    maxOutAmount: str
    minOutAmount: str
    openTx: str
    orderKey: str
    outReceived: str
    outWithdrawn: str
    outputMint: str
    rawInAmountPerCycle: str
    rawInDeposited: str
    rawInUsed: str
    rawInWithdrawn: str
    rawMaxOutAmount: str
    rawMinOutAmount: str
    rawOutReceived: str
    rawOutWithdrawn: str
    trades: List[OrderHistoryResponse]
    updatedAt: AwareDatetime
    userClosed: bool
    userPubkey: str


class Withdrawal(Enum):
    In = 'In'
    Out = 'Out'


class AllRecurringResponse1(TimeRecurringResponse):
    model_config = ConfigDict(
        extra='allow',
    )
    recurringType: Literal['time']


class AllRecurringResponse2(PriceRecurringResponse):
    model_config = ConfigDict(
        extra='allow',
    )
    recurringType: Literal['price']
    """
    DEPRECATED: Price-based recurring orders are deprecated
    """


class CloseRecurring(BaseModel):
    model_config = ConfigDict(
        extra='allow',
    )
    order: str
    """
    Base-58 account which is the Recurring Order account
    """
    recurringType: CloseRecurringType
    user: str


class GetRecurringOrderParams(BaseModel):
    model_config = ConfigDict(
        extra='allow',
    )
    includeFailedTx: bool
    mint: Optional[str] = None
    orderStatus: OrderState
    page: Optional[conint(ge=1)] = None
    recurringType: RecurringOrderType
    user: str


class GetRecurringOrderResponse1(BaseModel):
    model_config = ConfigDict(
        extra='allow',
    )
    orderStatus: OrderState
    page: conint(ge=1)
    time: List[TimeRecurringResponse]
    totalPages: conint(ge=1)
    user: str


class GetRecurringOrderResponse2(BaseModel):
    model_config = ConfigDict(
        extra='allow',
    )
    orderStatus: OrderState
    page: conint(ge=1)
    price: List[PriceRecurringResponse]
    totalPages: conint(ge=1)
    user: str


class GetRecurringOrderResponse3(BaseModel):
    model_config = ConfigDict(
        extra='allow',
    )
    all: List[Union[AllRecurringResponse1, AllRecurringResponse2]]
    orderStatus: OrderState
    page: conint(ge=1)
    totalPages: conint(ge=1)
    user: str


class GetRecurringOrderResponse(
    RootModel[
        Union[
            GetRecurringOrderResponse1,
            GetRecurringOrderResponse2,
            GetRecurringOrderResponse3,
        ]
    ]
):
    root: Union[
        GetRecurringOrderResponse1,
        GetRecurringOrderResponse2,
        GetRecurringOrderResponse3,
    ]


class RecurringType1(BaseModel):
    model_config = ConfigDict(
        extra='allow',
    )
    time: TimeRecurringCreationParams


class WithdrawPriceRecurring(BaseModel):
    model_config = ConfigDict(
        extra='allow',
    )
    amount: Optional[conint(ge=0)] = None
    """
    If no `amount` is provided, it will withdraw the entire amount
    """
    inputOrOutput: Withdrawal
    order: str
    """
    Base-58 account which is the Recurring Order account
    """
    user: str


class CreateRecurring(BaseModel):
    model_config = ConfigDict(
        extra='allow',
    )
    inputMint: str
    outputMint: str
    params: Union[RecurringType1, RecurringType2]
    user: str
